Timer unit: 3.66551e-07 s

Total time: 52.43 s
File: C:\DataD\Work\CERBERO\CLP\SCLPsolver\subroutines\SCLP_pivot5.py
Function: SCLP_pivot at line 8

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     8                                           #'#@profile
     9                                           def SCLP_pivot(Kset_0, Jset_N, solution, N1, N2, v1, v2, KK, JJ, NN, totalK, totalJ,
    10                                                          DEPTH, STEPCOUNT, ITERATION, settings, tolerance):
    11                                           
    12       613       3710.0      6.1      0.0      pivot_problem = {'result': 0}
    13       613       4800.0      7.8      0.0      if N1 == -1:
    14        27        370.0     13.7      0.0          pbaseB1 = np.array([])
    15        27         92.0      3.4      0.0          AAN1 = None
    16        27     236889.0   8773.7      0.2          AAN2 = solution.get_basis_at(N2)
    17        27        205.0      7.6      0.0          BB2 = AAN2['A']
    18        27        101.0      3.7      0.0          pbaseB2 = AAN2['prim_name']
    19        27        101.0      3.7      0.0          dbaseB2 = AAN2['dual_name']
    20        27       1393.0     51.6      0.0          Jset = dbaseB2[dbaseB2 < 0]
    21        27        108.0      4.0      0.0          Kset = Kset_0
    22        27        368.0     13.6      0.0          if  not isinstance(v1, list):
    23        27       1116.0     41.3      0.0              Jset = Jset[Jset!=v1]
    24        27        187.0      6.9      0.0              if v1 > 0:
    25        13        850.0     65.4      0.0                  Kset = np.append(Kset, v1)
    26                                                   else:
    27                                                       print('v1',v1)
    28        27     622499.0  23055.5      0.4          pbaseDD, dbaseDD, DD = LP_formulate(BB2, pbaseB2, dbaseB2, Kset, Jset, tolerance)
    29        27       8607.0    318.8      0.0          pp21 = np.setdiff1d(pbaseDD, pbaseB2, assume_unique=True)
    30        27      11499.0    425.9      0.0          pp22 = np.setdiff1d(dbaseDD, dbaseB2, assume_unique=True)
    31                                                   #piv1 = [pp21.tolist()+pp22.tolist()]
    32        27        945.0     35.0      0.0          piv1 = pivot_storage(pp21.tolist(),pp22.tolist())
    33        27        383.0     14.2      0.0          if np.size(pp21) == 0 and np.size(pp22) == 0:
    34                                                       print('Basis B2 is optimal')
    35                                                       return solution, STEPCOUNT, ITERATION, pivot_problem
    36       586       3505.0      6.0      0.0      elif N2 == NN:
    37       307       8187.0     26.7      0.0          pbaseB2 = np.array([])
    38       307   30089995.0  98013.0     21.0          AAN1 = solution.get_basis_at(N1)
    39       307       4374.0     14.2      0.0          AAN2 = None
    40       307       1607.0      5.2      0.0          BB1 = AAN1['A']
    41       307       1499.0      4.9      0.0          pbaseB1 = AAN1['prim_name']
    42       307       1447.0      4.7      0.0          dbaseB1 = AAN1['dual_name']
    43       307      15063.0     49.1      0.0          dbaseB2 = np.array([])
    44       307      23267.0     75.8      0.0          Kset = pbaseB1[pbaseB1 > 0]
    45       307      12036.0     39.2      0.0          Jset = [-v for v in Jset_N]
    46       307       6587.0     21.5      0.0          if not isinstance(v2, list):
    47       307      16731.0     54.5      0.0              Kset = Kset[Kset!=v2]
    48       307       2660.0      8.7      0.0              if v2 < 0:
    49         1        113.0    113.0      0.0                  Jset = np.append(Jset, -v2)
    50                                                   else:
    51                                                       print('v2', v2)
    52       307   35418416.0 115369.4     24.8          pbaseDD, dbaseDD, DD = LP_formulate(BB1, pbaseB1, dbaseB1, Kset, Jset, tolerance)
    53       307     181642.0    591.7      0.1          pp11 = np.setdiff1d(pbaseB1, pbaseDD, assume_unique=True)
    54       307     168294.0    548.2      0.1          pp12 = np.setdiff1d(dbaseB1, dbaseDD, assume_unique=True)
    55                                                   #piv1 = [pp11.tolist()+ pp12.tolist()]
    56       307      14160.0     46.1      0.0          piv1 = pivot_storage(pp11.tolist(), pp12.tolist())
    57       307       5327.0     17.4      0.0          if np.size(pp11) == 0 and np.size(pp12) == 0:
    58                                                       print('Basis B1 is optimal')
    59                                                       return solution, STEPCOUNT, ITERATION, pivot_problem
    60                                               else:
    61       279   27768905.0  99530.1     19.4          AAN1, AAN2 = solution.get_bases(N1, N2)
    62       279       4035.0     14.5      0.0          BB2 = AAN2['A']
    63       279       1625.0      5.8      0.0          pbaseB1 = AAN1['prim_name']
    64       279       1512.0      5.4      0.0          dbaseB1 = AAN1['dual_name']
    65       279       1483.0      5.3      0.0          pbaseB2 = AAN2['prim_name']
    66       279       1489.0      5.3      0.0          dbaseB2 = AAN2['dual_name']
    67                                           
    68       279       5486.0     19.7      0.0          if isinstance(v1, list) or isinstance(v2, list):
    69         1        563.0    563.0      0.0              vv =np.setdiff1d(pbaseB1, pbaseB2, assume_unique=True)
    70         1          7.0      7.0      0.0              if isinstance(v2, list):
    71         1          3.0      3.0      0.0                  v2 = vv
    72                                                       else:
    73                                                           v1 = vv
    74       279      20501.0     73.5      0.0          Kset = pbaseB1[pbaseB1 > 0]
    75       279      10453.0     37.5      0.0          Kset = Kset[Kset != v2]
    76       279      15205.0     54.5      0.0          Jset = dbaseB2[dbaseB2 < 0]
    77       279       7588.0     27.2      0.0          Jset = Jset[Jset != v1]
    78       279   44391975.0 159111.0     31.0          pbaseDD, dbaseDD, DD = LP_formulate(BB2, pbaseB2, dbaseB2, Kset, Jset, tolerance)
    79       279     170714.0    611.9      0.1          pp21 = np.setdiff1d(pbaseDD, pbaseB2, assume_unique=True)
    80       279     160249.0    574.4      0.1          pp22 = np.setdiff1d(dbaseDD, dbaseB2, assume_unique=True)
    81       279     114862.0    411.7      0.1          pp11 = np.setdiff1d(pbaseB1, pbaseDD, assume_unique=True)
    82       279     147338.0    528.1      0.1          pp12 = np.setdiff1d(dbaseB1, dbaseDD, assume_unique=True)
    83       279      13497.0     48.4      0.0          piv1 = pivot_storage(pp11.tolist() + pp21.tolist(), pp12.tolist()  + pp22.tolist())
    84                                                   #piv1 = [pp11.tolist()+ pp12.tolist(),pp21.tolist()+ pp22.tolist()]
    85       613       4889.0      8.0      0.0      objective = DD[0, 0]
    86                                           
    87       613       6758.0     11.0      0.0      if objective == np.inf or objective == -np.inf:
    88                                                   if N1 == -1:
    89                                                       print('***  beyond this primal problem is unbounded, dual is infeasible')
    90                                                       cases = 'unbound_'
    91                                                   elif N2 == NN:
    92                                                       print('***  beyond this primal problem is infeasible, dual is unbounded')
    93                                                       cases = 'infeas__'
    94                                                   else:
    95                                                       raise Exception('*** infeasibility in middle of base sequence')
    96                                                   return solution, STEPCOUNT, ITERATION, pivot_problem
    97                                           
    98       613       2822.0      4.6      0.0      i1 = 1
    99       613       2680.0      4.4      0.0      i2 = 1
   100       613       6331.0     10.3      0.0      if N1 >= 0:
   101       586       7243.0     12.4      0.0          i1 = np.size(pp11)
   102       613       3779.0      6.2      0.0      if N2 < NN:
   103       306       2588.0      8.5      0.0          i2 = np.size(pp21)
   104       613       3032.0      4.9      0.0      if i1 == 1 and i2 == 1:
   105       600     269059.0    448.4      0.2          dx, dq = extract_rates(pbaseDD, dbaseDD, DD, KK, JJ, totalK, totalJ)
   106       600    2742459.0   4570.8      1.9          solution.update_caseII(N1, N2, np.reshape(pbaseDD,(-1,1)), np.reshape(dbaseDD,(-1,1)), dx, dq, AAN1, AAN2, piv1, 1, {'prim_name': pbaseDD, 'dual_name': dbaseDD, 'A': DD})
   107       600       4356.0      7.3      0.0          return solution, STEPCOUNT, ITERATION, pivot_problem
   108                                               else:
   109        13         64.0      4.9      0.0          if N1 == -1:
   110                                                       Kex1 =  np.intersect1d(pbaseDD[pbaseDD > 0], Kset_0, assume_unique=True)
   111                                                       Kexclude =  np.intersect1d(Kex1, pbaseB2[pbaseB2 > 0], assume_unique=True)
   112                                                       Jexclude = -np.intersect1d(dbaseDD[dbaseDD < 0], dbaseB2[dbaseB2 < 0], assume_unique=True)
   113        13         60.0      4.6      0.0          elif N2 == NN:
   114        12       6111.0    509.2      0.0              Kexclude =  np.intersect1d(pbaseDD[pbaseDD > 0], pbaseB1[pbaseB1 > 0], assume_unique=True)
   115        12       3381.0    281.8      0.0              Jex1 =  np.intersect1d(dbaseDD[dbaseDD < 0], [-v for v in Jset_N], assume_unique=True)
   116        12       2614.0    217.8      0.0              Jexclude = -np.intersect1d(Jex1, dbaseB1[dbaseB1 < 0], assume_unique=True)
   117                                                   else:
   118         1        766.0    766.0      0.0              Kexclude =  np.intersect1d(pbaseB1[pbaseB1 > 0], pbaseB2[pbaseB2 > 0], assume_unique=True)
   119         1        644.0    644.0      0.0              Jexclude = -np.intersect1d(dbaseB1[dbaseB1 < 0], dbaseB2[dbaseB2 < 0], assume_unique=True)
   120         1         16.0     16.0      0.0              if not isinstance(v1, list):
   121         1         47.0     47.0      0.0                  Kexclude = Kexclude[Kexclude != v1]
   122         1         33.0     33.0      0.0                  Jexclude = Jexclude[Jexclude != -v1]
   123         1          9.0      9.0      0.0              if not isinstance(v2, list):
   124         1         48.0     48.0      0.0                  Kexclude = Kexclude[Kexclude != v2]
   125         1         34.0     34.0      0.0                  Jexclude = Jexclude[Jexclude != -v2]
   126                                                   prim_name, dual_name, dx, dq, pivots, Nnew, STEPCOUNT, ITERATION, pivot_problem =\
   127        13         76.0      5.8      0.0           SCLP_subproblem(pbaseDD, dbaseDD, DD, N1, N2, v1, v2, Kexclude, Jexclude, pbaseB1, pbaseB2, AAN1, AAN2, KK, JJ,
   128        13     245058.0  18850.6      0.2                              NN, totalK, totalJ, DEPTH+1, STEPCOUNT, ITERATION, settings, tolerance)
   129        13        214.0     16.5      0.0          if pivot_problem['result'] == 0:
   130        13      14269.0   1097.6      0.0              solution.update_caseII(N1, N2, prim_name, dual_name, dx, dq, AAN1, AAN2, pivots, Nnew)
   131        13         89.0      6.8      0.0      return solution, STEPCOUNT, ITERATION, pivot_problem

Total time: 92.6551 s
File: C:\DataD\Work\CERBERO\CLP\SCLPsolver\subroutines\SCLP_solver5.py
Function: SCLP_solver at line 9

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     9                                           #'#@profile
    10                                           def SCLP_solver(solution, x_0, del_x_0, q_N, del_q_N, T, del_T, ThetaBar, cases, B1, B2, klist, jlist, totalK, totalJ, DEPTH, STEPCOUNT, ITERATION, settings, tolerance):
    11                                           
    12        14        102.0      7.3      0.0      ITERATION[DEPTH] = 0
    13                                           
    14        14         89.0      6.4      0.0      KK = len(klist)
    15        14         65.0      4.6      0.0      JJ = len(jlist)
    16                                           
    17        14         56.0      4.0      0.0      theta = 0
    18        14         57.0      4.1      0.0      tol_coeff = 1  # tolerance multiplier
    19        14         60.0      4.3      0.0      prevProblem = 0
    20        14         74.0      5.3      0.0      lastCollision = dict()
    21        14         73.0      5.2      0.0      pivot_problem = {'result' : 0}
    22                                           
    23        14      49922.0   3565.9      0.0      Kset_0 = klist[np.hstack(np.logical_or(x_0 > 0, np.logical_and(x_0 == 0, del_x_0 > 0)))]
    24        14     277425.0  19816.1      0.1      Jset_N = jlist[np.hstack(np.logical_or(q_N > 0, np.logical_and(q_N == 0, del_q_N > 0)))]
    25                                           
    26        14        165.0     11.8      0.0      if len(B1) > 0 or len(B2) > 0:
    27        13         53.0      4.1      0.0          check_complete = True
    28                                               else:
    29         1          4.0      4.0      0.0          check_complete = False
    30                                           
    31       634       4431.0      7.0      0.0      while cases != 'complete' and cases != 'solved__':
    32                                           
    33       620      41127.0     66.3      0.0          if not solution.base_sequence.check_places():
    34                                                       raise Exception('Bases placement failure!')
    35                                           
    36       620   13998036.0  22577.5      5.5          dx = solution.dx.get_matrix()
    37       620   13686395.0  22074.8      5.4          dq = solution.dq.get_matrix()
    38       620    2158777.0   3481.9      0.9          sdx = np.sign(dx)
    39       620    2273929.0   3667.6      0.9          sdq = np.sign(dq)
    40       620    2725278.0   4395.6      1.1          check_sd(sdx, True)
    41       620    2738048.0   4416.2      1.1          check_sd(sdq, False)
    42       620       6161.0      9.9      0.0          if STEPCOUNT == 174:
    43         1        337.0    337.0      0.0              print('bbb')
    44                                           
    45       620    4834832.0   7798.1      1.9          tau, dtau = calc_equations(klist, jlist, solution.pivots, x_0, del_x_0, q_N, del_q_N, T, del_T, dx, dq)
    46       620   36065937.0  58170.9     14.3          x, del_x, q, del_q = calc_states(dx, dq, x_0, del_x_0, q_N, del_q_N, tau, dtau, sdx, sdq, tolerance)
    47       620       8184.0     13.2      0.0          test1 = 0
    48       620       3074.0      5.0      0.0          test2 = 0
    49       620       3543.0      5.7      0.0          if check_complete:
    50        27        166.0      6.1      0.0              if len(B1) > 0:
    51        27      21641.0    801.5      0.0                  test1 = solution.get_name_diff_with0(B1).size
    52        27        180.0      6.7      0.0              if len(B2) > 0:
    53         2       1655.0    827.5      0.0                  test2 = solution.get_name_diff_withN(B2).size
    54       620       3070.0      5.0      0.0          if check_complete and test1 == 0 and test2 == 0:
    55        13        169.0     13.0      0.0              cases, Delta, N1, N2, v1, v2, problem = get_complete(dx.shape[1])
    56                                                   else:
    57       607       4857.0      8.0      0.0              cases, Delta, N1, N2, v1, v2, problem = classification(tau, dtau, klist, jlist, dx, dq, x, del_x, q, del_q,
    58       607   25629385.0  42223.0     10.1                                                                     solution.pivots, B1, B2, sdx, sdq, tolerance, 1)
    59       620       4185.0      6.8      0.0          if problem['result'] == 1 or problem['result'] == 2 or problem['result'] == 3:
    60                                                       #TODO: review next if for bugs
    61                                                       if problem['result'] == 2 and problem['timeProblem']['result'] == 2 and tol_coeff > 10000 and\
    62                                                               len(np.intersect1d(problem['timeProblem']['data'], np.arange(lastCollision['N1']+1, lastCollision['N2']), assume_unique=True))==0:
    63                                                           tol_coeff = 0.1
    64                                                           while problem['result'] == 2 and tol_coeff > 0.0001:
    65                                                               print('trying to resolve * ', tol_coeff, ' ...')
    66                                                               test1 = 0
    67                                                               test2 = 0
    68                                                               if check_complete:
    69                                                                   if len(B1) > 0:
    70                                                                       test1 = solution.get_name_diff_with0(B1).size
    71                                                                   if len(B2) > 0:
    72                                                                       test2 = solution.get_name_diff_withN(B2).size
    73                                                               if check_complete and test1 == 0 and test2 == 0:
    74                                                                   cases, Delta, N1, N2, v1, v2, problem = get_complete(dx.shape[1])
    75                                                               else:
    76                                                                   cases, Delta, N1, N2, v1, v2, problem = classification(tau, dtau, klist, jlist, dx, dq, x, del_x, q, del_q,
    77                                                                                                                  solution.pivots, B1, B2, sdx, sdq, tolerance, tol_coeff)
    78                                                               tol_coeff = 0.1 * tol_coeff
    79                                                           tol_coeff = 1
    80                                                       else:
    81                                                           tol_coeff = 10 * tol_coeff
    82                                                           prevProblem = problem['result']
    83                                                           if 'data' in problem.keys():
    84                                                               print('Problem data: ',str(problem['data']))
    85       620       3473.0      5.6      0.0          elif problem['result'] == 4:
    86                                                       print('More than two variables leave in time shrink ....')
    87                                                       while tol_coeff <= 10000 and problem['result'] == 4:
    88                                                           if tol_coeff < 10 and prevProblem !=2:
    89                                                               if N2 - N1 == 2 or tol_coeff <= 0.001:
    90                                                                   tol_coeff = 10
    91                                                               else:
    92                                                                   tol_coeff = 0.1 * tol_coeff
    93                                                           else:
    94                                                               tol_coeff = 10 * tol_coeff
    95                                                           print('trying to resolve * ', tol_coeff, ' ...')
    96                                                           test1 = 0
    97                                                           test2 = 0
    98                                                           if check_complete:
    99                                                               if len(B1) > 0:
   100                                                                   test1 = solution.get_name_diff_with0(B1).size
   101                                                               if len(B2) > 0:
   102                                                                   test2 = solution.get_name_diff_withN(B2).size
   103                                                           if check_complete and test1 == 0 and test2 == 0:
   104                                                               cases, Delta, N1, N2, v1, v2, problem = get_complete(dx.shape[1])
   105                                                           else:
   106                                                               cases, Delta, N1, N2, v1, v2, problem = classification(tau, dtau, klist, jlist, dx, dq, x, del_x, q,
   107                                                                                                                      del_q, solution.pivots, B1, B2, sdx, sdq, tolerance,
   108                                                                                                                      tol_coeff)
   109                                                       if problem['result'] == 0:
   110                                                           tol_coeff = 1
   111                                                           print('ok!')
   112                                                       else:
   113                                                           print('fail!')
   114                                                       prevProblem = 4
   115                                                   else:
   116       620       3368.0      5.4      0.0              tol_coeff = 1
   117       620       3280.0      5.3      0.0              prevProblem = problem['result']
   118                                           
   119       620       3262.0      5.3      0.0          if problem['result'] > 0 and DEPTH == 0:
   120                                                       if lastCollision['cases'] == 'Case ii_':
   121                                                           # rewinding to previous iteration
   122                                                           print('rewind... trying to resolve * ', tol_coeff, ' ...')
   123                                                           Delta = lastCollision['Delta']
   124                                                           x_0 = x_0 - del_x_0 * Delta
   125                                                           q_N = q_N - del_q_N * Delta
   126                                                           T = T - del_T * Delta
   127                                                           theta = theta - Delta
   128                                                           #             v1 = lastCollision.v2 #change varible order
   129                                                           #             v2 = lastCollision.v1 #change varible order
   130                                                           solution.update_rewind(lastCollision['N1'], lastCollision['N2'], lastCollision['Nnew'],
   131                                                                                  lastCollision['old_pn'], lastCollision['old_dn'],
   132                                                                                  lastCollision['old_dx'], lastCollision['old_dq'], lastCollision['old_pivots'])
   133                                                           dx = solution.dx.get_matrix()
   134                                                           dq = solution.dq.get_matrix()
   135                                                           sdx = np.sign(dx)
   136                                                           sdq = np.sign(dq)
   137                                           
   138                                                           tau, dtau = calc_equations(klist, jlist, solution.pivots, x_0, del_x_0, q_N, del_q_N, T, del_T, dx, dq)
   139                                                           x, del_x, q, del_q = calc_states(dx, dq, x_0, del_x_0, q_N, del_q_N, tau, dtau, sdx, sdq, tolerance)
   140                                                           test1 = 0
   141                                                           test2 = 0
   142                                                           if check_complete:
   143                                                               if len(B1) > 0:
   144                                                                   test1 = solution.get_name_diff_with0(B1).size
   145                                                               if len(B2) > 0:
   146                                                                   test2 = solution.get_name_diff_withN(B2).size
   147                                                           if check_complete and test1 == 0 and test2 == 0:
   148                                                               cases, Delta, N1, N2, v1, v2, problem = get_complete(dx.shape[1])
   149                                                           else:
   150                                                               cases, Delta, N1, N2, v1, v2, problem = classification(tau, dtau, klist, jlist, dx, dq, x, del_x, q,
   151                                                                                                                      del_q, solution.pivots, B1, B2, sdx, sdq,
   152                                                                                                                      tolerance, tol_coeff)
   153                                                           if problem['result'] == 4:
   154                                                               while tol_coeff >= 0.001 and problem['result'] == 4:
   155                                                                   if tol_coeff >= 10:
   156                                                                       if tol_coeff <= 1000:
   157                                                                           tol_coeff = 10 * tol_coeff
   158                                                                       else:
   159                                                                           tol_coeff = 0.1
   160                                                                   else:
   161                                                                       tol_coeff = 0.1 * tol_coeff
   162                                                                   print('trying to resolve * ', tol_coeff, ' ...')
   163                                                                   test1 = 0
   164                                                                   test2 = 0
   165                                                                   if check_complete:
   166                                                                       if len(B1) > 0:
   167                                                                           test1 = solution.get_name_diff_with0(B1).size
   168                                                                       if len(B2) > 0:
   169                                                                           test2 = solution.get_name_diff_withN(B2).size
   170                                                                   if check_complete and test1 == 0 and test2 == 0:
   171                                                                       cases, Delta, N1, N2, v1, v2, problem = get_complete(dx.shape[1])
   172                                                                   else:
   173                                                                       cases, Delta, N1, N2, v1, v2, problem = classification(tau, dtau, klist, jlist, dx, dq, x,
   174                                                                                                                              del_x, q, del_q, solution.pivots, B1,
   175                                                                                                                              B2, sdx, sdq, tolerance, tol_coeff)
   176                                                                   if problem['result'] == 0:
   177                                                                       tol_coeff = 1
   178                                                                       print('ok!')
   179                                                                   else:
   180                                                                       print('fail!')
   181                                           
   182       620       3575.0      5.8      0.0          if cases == 'complete' and DEPTH > 0:
   183        13        208.0     16.0      0.0              Delta = min(0.1 * theta, (1 - theta) / 2)
   184                                           
   185       620       5348.0      8.6      0.0          if DEPTH == 0 and theta + Delta > ThetaBar:
   186         1          6.0      6.0      0.0              cases = 'solved__'
   187         1          9.0      9.0      0.0              Delta = ThetaBar - theta
   188                                           
   189       620       3234.0      5.2      0.0          if cases == 'complete' and DEPTH == 0:
   190                                                       Delta = 0.1 * theta
   191                                           
   192       620       4686.0      7.6      0.0          NN = len(tau)
   193       620       3747.0      6.0      0.0          STEPCOUNT = STEPCOUNT + 1
   194                                           
   195       620       4415.0      7.1      0.0          ITERATION[DEPTH] = ITERATION[DEPTH] + 1
   196       620       3494.0      5.6      0.0          theta1 = theta + Delta
   197                                           
   198       620       4054.0      6.5      0.0          if theta1 >= 1 and DEPTH > 0 and cases != 'complete':
   199                                                       print("Theta > 1....")
   200                                                       pivot_problem['result'] = 1
   201                                                       return solution, x_0, q_N, T, STEPCOUNT, pivot_problem
   202                                           
   203                                                       #cases = 'theta>1_'
   204                                           
   205       620     270500.0    436.3      0.1          print(STEPCOUNT, DEPTH, ITERATION[DEPTH], JJ, 'x', KK, NN, theta, theta1, cases, N1, N2, v1, v2, len(solution.base_sequence.places))
   206       620       5099.0      8.2      0.0          lastCollision = {'cases': cases, 'theta': theta, 'Delta': Delta,
   207       620      13721.0     22.1      0.0                                   'N1': N1, 'N2': N2, 'v1': v1, 'v2': v2}
   208       620       4076.0      6.6      0.0          if cases == 'Case i__':
   209         7      71794.0  10256.3      0.0              solution.update_caseI(N1, N2)
   210       613       3823.0      6.2      0.0          elif cases == 'Case ii_' or cases == 'Case iii':
   211       599       3465.0      5.8      0.0              if cases == 'Case ii_':
   212       278      53443.0    192.2      0.0                  store_collision_info(N1, N2, lastCollision, solution)
   213                                           
   214       599       4519.0      7.5      0.0              solution, STEPCOUNT, ITERATION, pivot_problem = SCLP_pivot(Kset_0, Jset_N, solution, N1, N2, v1,
   215       599       3584.0      6.0      0.0                                                                       v2, KK, JJ, NN, totalK, totalJ, DEPTH,
   216       599  147621271.0 246446.2     58.4                                                                       STEPCOUNT, ITERATION, settings, tolerance)
   217       599      21970.0     36.7      0.0              lastCollision['Nnew'] = solution.NN - NN
   218                                           
   219       599       5604.0      9.4      0.0              while pivot_problem['result'] == 1 and tol_coeff < 0.001/tolerance: # theta > 1
   220                                                           tol_coeff = tol_coeff * 10
   221                                                           print('trying to resolve * ', tol_coeff, '...')
   222                                                           test1 = 0
   223                                                           test2 = 0
   224                                                           if check_complete:
   225                                                               if len(B1) > 0:
   226                                                                   test1 = solution.get_name_diff_with0(B1).size
   227                                                               if len(B2) > 0:
   228                                                                   test2 = solution.get_name_diff_withN(B2).size
   229                                                           if check_complete and test1 == 0 and test2 == 0:
   230                                                               cases, Delta, N1, N2, v1, v2, problem = get_complete(dx.shape[1])
   231                                                           else:
   232                                                               cases, Delta, N1, N2, v1, v2, problem = classification(tau, dtau, klist, jlist, dx, dq, x,
   233                                                                                                                      del_x, q, del_q, solution.pivots, B1,
   234                                                                                                                      B2, sdx, sdq, tolerance, tol_coeff)
   235                                                           print(STEPCOUNT, DEPTH, ITERATION[DEPTH], JJ, 'x', KK, NN, theta, theta1, cases, N1, N2, v1, v2,
   236                                                                 len(solution.base_sequence.places))
   237                                                           if cases == 'Case i__':
   238                                                               solution.update_caseI(N1, N2)
   239                                                               pivot_problem['result'] = 0
   240                                                           elif cases == 'Case ii_' or cases == 'Case iii':
   241                                                               if cases == 'Case ii_':
   242                                                                   store_collision_info(N1, N2, lastCollision, solution)
   243                                                               solution, STEPCOUNT, ITERATION, pivot_problem = SCLP_pivot(Kset_0, Jset_N, solution, N1, N2, v1,
   244                                                                                                                      v2, KK, JJ, NN, totalK, totalJ, DEPTH,
   245                                                                                                                      STEPCOUNT, ITERATION, settings,
   246                                                                                                                      tolerance)
   247                                                           lastCollision['Nnew'] = solution.NN - NN
   248       599       3813.0      6.4      0.0              if pivot_problem['result'] == 1:
   249                                                           if DEPTH > 0:
   250                                                               return solution, x_0, q_N, T, STEPCOUNT, pivot_problem
   251                                           
   252                                                       #statData = {'cases': cases, 'N1': N1, 'N2': N2, 'minBases': settings['minBases'],
   253                                                       #            'maxBases': settings['maxBases'], 'basesRate': settings['basesRate']}
   254                                                       #base_sequence = clearBaseSequence(base_sequence, statData)
   255                                           
   256                                           
   257       620      54436.0     87.8      0.0          x_0 = x_0 + del_x_0 * Delta
   258       620      35163.0     56.7      0.0          q_N = q_N + del_q_N * Delta
   259       620       8208.0     13.2      0.0          T = T + del_T * Delta
   260       620       3331.0      5.4      0.0          theta = theta1
   261                                           
   262        14         60.0      4.3      0.0      return solution, x_0, q_N, T, STEPCOUNT, pivot_problem

Total time: 9.34722 s
File: C:\DataD\Work\CERBERO\CLP\SCLPsolver\subroutines\classification5.py
Function: classification at line 8

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     8                                           #'#@profile
     9                                           def classification(tau,dtau,klist,jlist,dx,dq,x,del_x,q,del_q,pivots,B1,B2, sdx, sdq, tolerance, tol_coeff):
    10                                           #idenitfy next collision and classify it
    11                                           #problem
    12                                           #   result = 0 Ok
    13                                           #   result = 1 state prblem
    14                                           #   result = 2 time problem
    15                                           #   result = 3 state problem + time problem
    16                                           #   result = 4 compound problem
    17                                           #   result = 5 state problem + compound problem
    18                                           #   result = 6 time problem + compound problem
    19                                           #   result = 7 state problem + time problem + compound problem
    20                                           
    21       607       3636.0      6.0      0.0      max_tol_coeff = 0.01/tolerance
    22       607       1974.0      3.3      0.0      min_tol_coeff = 0.01
    23       607       3721.0      6.1      0.0      if tol_coeff == max_tol_coeff:
    24                                                   print("Maximum tolerance coefficient reached")
    25                                                   raise Exception()
    26       607       4176.0      6.9      0.0      NN = dx.shape[1]
    27       607       4758.0      7.8      0.0      problem = {'result': 0, 'stateProblem': [], 'timeProblem': [], 'compoundProblem': {'result':0, 'data': []}}
    28       607       2113.0      3.5      0.0      Delta = 0
    29       607       1665.0      2.7      0.0      N1 = -1
    30       607       1793.0      3.0      0.0      N2 = NN
    31       607       1874.0      3.1      0.0      v1 = []
    32       607       1981.0      3.3      0.0      v2 = []
    33       607       1778.0      2.9      0.0      case = ''
    34                                           
    35       607   24940100.0  41087.5     97.8      CC1, prob = calc_statecollide(klist,jlist,x,del_x,q,del_q, sdx, sdq, tolerance)
    36       607       8504.0     14.0      0.0      problem['stateProblem'] = prob
    37       607       3427.0      5.6      0.0      if prob['result'] != 0:
    38                                                   problem['result'] = 1
    39                                                   return '', Delta, N1, N2, v1, v2, problem
    40                                           
    41       607     298666.0    492.0      1.2      CC2, prob = calc_timecollide(tau,dtau,tolerance,tol_coeff)
    42       607       3261.0      5.4      0.0      problem['timeProblem'] = prob
    43       607       2259.0      3.7      0.0      if prob['result'] != 0:
    44                                                   problem['result'] = problem['result'] + 2
    45                                                   return '', Delta, N1, N2, v1, v2, problem
    46                                           
    47       607       3492.0      5.8      0.0      if 	len(CC1) == 0 and len(CC2) == 0:
    48                                                   case = 'complete'
    49                                                   Delta = np.inf
    50                                                   return case, Delta, N1, N2, v1, v2, problem
    51                                           
    52       607       1925.0      3.2      0.0      Didle = 0
    53       607       2991.0      4.9      0.0      if	len(CC1) > 0 and len(CC2) > 0:
    54       473       2731.0      5.8      0.0          Didle = CC1[0] - CC2[0]
    55       473       2557.0      5.4      0.0          if abs(Didle) <= tolerance:
    56                                                       Didle = 0
    57       473       2167.0      4.6      0.0          if Didle == 0 and not (CC2[1] - 1 <= CC1[1] and CC1[1] <= CC2[2]+1):
    58                                                       print('time shrink as well as state hits zero elsewhere\n')
    59                                                       problem['result'] = problem['result'] + 4
    60                                                       problem['compoundProblem']['result'] = 1
    61                                                       return '', Delta, N1, N2, v1, v2, problem
    62       607       3543.0      5.8      0.0      if	(len(CC1) > 0 and len(CC2) == 0) or Didle < 0:
    63       322        876.0      2.7      0.0          case = 'Case iii'
    64       322       1045.0      3.2      0.0          Delta = CC1[0]
    65       322        912.0      2.8      0.0          N1 = CC1[1]
    66       322       1954.0      6.1      0.0          N2 = CC1[1] + 1
    67       322       1665.0      5.2      0.0          if CC1[2] < 0:
    68        15         47.0      3.1      0.0              v1 = CC1[2]
    69                                                   else:
    70       307       1216.0      4.0      0.0              v2 = CC1[2]
    71       285       1463.0      5.1      0.0      elif (len(CC1) == 0 and len(CC2) > 0) or Didle >= 0:
    72       285        961.0      3.4      0.0          Delta = CC2[0]
    73       285       1385.0      4.9      0.0          N1 = CC2[1] - 1
    74       285       1534.0      5.4      0.0          N2 = CC2[2] + 1
    75       285       1570.0      5.5      0.0          if N1 == -1 or N2 == NN:
    76                                                       case = 'Case i__'
    77                                                   else:
    78       285      82285.0    288.7      0.3              vlist = pivots.get_difference(N1,N2)
    79       285       1470.0      5.2      0.0              if len(vlist) > 2:
    80                                                           problem['result'] = problem['result'] + 4
    81                                                           problem['compoundProblem']['result'] = 2
    82                                                           return '', Delta, N1, N2, v1, v2, problem
    83       285       1182.0      4.1      0.0              elif len(vlist) == 1:
    84         7         21.0      3.0      0.0                  case = 'Case i__'
    85         7         26.0      3.7      0.0                  return case, Delta, N1, N2, v1, v2, problem
    86       278       1211.0      4.4      0.0              elif len(vlist) == 2:
    87       278        859.0      3.1      0.0                  case = 'Case ii_'
    88       278       2469.0      8.9      0.0                  if (N2-N1)%2 > 0:
    89                                                               if tol_coeff<100:
    90                                                                   pass
    91                                                                   #print("Incompatible interval number... resolving * ", tol_coeff*10)
    92                                                                   #return classification(tau,dtau,klist,jlist,dx,dq,x,del_x,q,del_q,prim_name,B1,B2, sdx, sdq, tolerance, tol_coeff*10)
    93       278      76730.0    276.0      0.3                  order_ratio = calc_order_ratio(vlist[0],vlist[1],N1,N2,klist,jlist,dx,dq,x,del_x,q,del_q,tau,dtau,Delta/2)
    94       278       6995.0     25.2      0.0                  if abs(order_ratio-1) < tolerance * tol_coeff:
    95                                                               print('Tolerance in R unclear...')
    96       278       3146.0     11.3      0.0                  if abs(order_ratio) < 1: #the strange case when R < 0 should be perferctly reviewed
    97       278       1113.0      4.0      0.0                      v1 = vlist[0]
    98       278       1008.0      3.6      0.0                      v2 = vlist[1]
    99                                                           else:
   100                                                               v1 = vlist[1]
   101                                                               v2 = vlist[0]
   102       278        973.0      3.5      0.0                  return case, Delta, N1, N2, v1, v2, problem
   103       322       1253.0      3.9      0.0      return case, Delta, N1, N2, v1, v2, problem

